\section{AK Scheme}\label{subsec:ak}

\begin{algorithm}
  \KwIn{dataset $\mathcal{R}$ with scheme $(P, A_{0}, ..., A_{v-1})$, buyer $n$'s ID $id$}
  \KwOut{fingerprinted dataset $\mathcal{R'}$}
  fingerprint of buyer $n$: $\mathcal{F}(\mathcal{K},id)=\mathcal{H}(\mathcal{K}|id)$
  \\
  \ForEach{tuple $r \in \mathcal{R}$}
  {
    \If{$(\mathcal{S}_{1}(\mathcal{K}|r.P)$ mod $\gamma == 0)$}{
        attribute\_index $i = \mathcal{S}_2(\mathcal{K}|r.P)$ mod $v$
        \\
        bit\_index $j=\mathcal{S}_3(\mathcal{K}|r.P)$ mod $\xi$
        \\
        mask\_bit $x=0$ if $\mathcal{S}_4(\mathcal{K}|r.P)$ is even; $x=1$ otherwise
        \\
        fingerprint\_index $l=\mathcal{S}_5(\mathcal{K}|r.P)$ mod $L$
        \\
        fingerprint\_bit $f=f_l$
        \\
        mark\_bit $m=x \oplus f$
        \\
        $LSB(j,r.A_i) = m$
    }
  }
  \Return{$\mathcal{R'}$}
  \caption{AK Scheme: Insertion Algorithm}
  \label{alg:AK-insertion} 
\end{algorithm}

\begin{algorithm}
  \KwIn{fingerprinted dataset $\mathcal{R'}$ with scheme $(P, A_0, ..., A_{v-1})$}
  \KwOut{suspected buyer's ID $id$}
  //initiate fingerprint template and counts \\
  fingerprint template $\mathcal{F}=(f_0,...,f_{L-1})=(?,...,?)$ // '?' represents unknown value \\
  \For{$i=0$ to $L-1$}
  {
    $count[i][0]=count[i][1]=0$ \\
    // $count[i][0]=count[i][1]$ are votes for $f_i$ to be 0 and 1 respectively
  }
  //scan all tuples and obtain counts for each fingerprint bit \\
  \ForEach{tuple $r \in R'$}
  {
    \If{$\mathcal{S}_1(\mathcal{K},r.P)$ mod $\gamma==0$}
    {
        attribute\_index $i=\mathcal{S}_2(\mathcal{K},r.P)$ mod $v$\\
        bit\_index $j=\mathcal{S}_3(\mathcal{K}, r.P)$ mod $v$\\
        mark\_bit $m=LSB(j, r.A_i)$\\
        mask\_bit $x=0$ if $\mathcal{S}_4(\mathcal{K},r.P)$ is even; $x=1$ otherwise\\
        fingerprint\_bit $f=m \oplus x$\\
        fingerprint\_index $l=\mathcal{S}_5(\mathcal{K},r.P)$ mod $L$\\
        //update the votes\\
        $count[l][f]++$ 
    }
  }
  //recover the fingerprint\\
  \For{$l=0$ to $L-1$}
  {
    \If{$count[l][0]+count[l][1]==0$}
    {
        \Return{\textit{none suspected}}
    }
    $f_l=0$ if $count[l][0]/(count[l][0]+count[l][1])>\tau$\\
    $f_l=1$ if $count[l][1]/(count[l][0]+count[l][1])>\tau$\\
    \Return{\textit{none suspected}} otherwise
  }
  $\mathcal{F}=(f_0,...,f_{L-1})$\\
  //determine a source of leakage\\
  $id=detect(\mathcal{F,K},L, N)$\\
  \uIf{$id\geq0$}
  {
    \Return{$id$}
  }
  \Else
  {
    \Return{\textit{none suspected}}
  }
  \caption{AK Scheme: Detection Algorithm}
  \label{alg:AK-detection} 
\end{algorithm}

\begin{algorithm}
  \textit{detect}(template $\mathcal{F}$, secret key $\mathcal{K}$, fingerp. length $L$, number of buyers $N$):\\
  \For{each buyer n}
  {
    $\mathcal{F}'=\mathcal{H}(\mathcal{K}|id)$\\
    \If{$\mathcal{F}==\mathcal{F}'$}{\Return{id}}
    \Return{-1}
  }
  \caption{AK Scheme: Subroutine \textit{detect}}
  \label{alg:detect-subroutine} 
\end{algorithm}

In \cite{li2005fingerprinting} the authors describe a fingerprinting scheme that is an extension of the watermarking scheme from \cite{agrawal2003watermarking}. 
In this thesis, this fingerprinting scheme will be referred to as AK Scheme whose name is made of last name initials of authors of the underlying watermarking technique, Rakesh Agrawal and Jerry Kiernan.

\subsection{Algorithms}
\paragraph{Insertion}
Algorithm \ref{alg:AK-insertion} shows the pseudo-code of the insertion algorithm, which is used to embed a fingerprint of a buyer \textit{n} into the dataset $\mathcal{R}$. 
Using random numbers generated by a pseudo-random sequence generator $\mathcal{S}$ the algorithm chooses the bit within the dataset's values that will be marked, as well as the bit that will be embedded.
The pseudo-random sequence generator is independently seeded for each tuple with a concatenation of the owner's secret key $\mathcal{K}$ and the primary key of each tuple. 
In the line 3, the algorithm decides whether the current tuple will be marked, based on the generated number $\mathcal{S}_1(\mathcal{K}, r.P)$. 
In lines 4 and 5, based on $\mathcal{S}_2(\mathcal{K}, r.P)$ and $\mathcal{S}_3(\mathcal{K}, r.P)$, it is decided which one of the attribute's values will be marked, and which least significant bit of the value, respectively. 
In lines 6-10 the algorithm determines which value to replace this bit with. 
The next numbers, generated by the sequence generator $\mathcal{S}_4(\mathcal{K}, r.P)$ and $\mathcal{S}_5(\mathcal{K}, r.P)$, decide the mask bit and choose the fingerprint bit, respectively.
Finally, the resulting bit that is embedded in the line 10 at the chosen place in a dataset is the result of applying XOR function on the mask bit and the fingerprint bit.

\begin{table}[ht]
    \centering
    \caption{Sample dataset}
    \label{tab:exemplary_dataset}
    \begin{tabular}{|c|c|c|}
        \hline
         Primary key & Attribute 0 & Attribute 1  \\
         \hline
         1 & 34 & 749 \\
         \hline
         2 & 21 & 265 \\
         \hline
    \end{tabular}
\end{table}
Assume we want to fingerprint a very simple dataset shown in \Cref{tab:exemplary_dataset} with a fingerprint 11110000.
We use the value 01010101 as a secret key $\mathcal{K}$. 
Furthermore, assume we want to mark on average every second tuple, i.e. $\gamma=2$ and consider the last two bits of value for marking; $\xi=2$.
The algorithm will use the random number sequence generator to produce a unique sequence of numbers for every tuple (different seed for every tuple).
\\Let \\
\hspace*{10 mm} $\mathcal{S}(01010101 | 0) = \{72,39,10,34,97\}$ and \\
\hspace*{10 mm} $\mathcal{S}(01010101 | 1) = \{21,37,62,25,16\}$.

Starting with the first tuple, the algorithm will choose it for marking because $\mathcal{S}_1 \text{ mod } \gamma = 72 \text{ mod } 2 = 0$.
Then the attribute index is chosen as $\mathcal{S}_2 \text{ mod } v = 39 \text{ mod } 2 = 1$ and bit index as $\mathcal{S}_3 \text{ mod } \xi = 10 \text{ mod } 2 = 1$, therefore we are marking 2nd LSB (because bit indices start with 0) of a value 749 which is 0; $751_{10} = 1011101101_2$.
Further, we decide the mark that is going to be applied to the bit. Firstly, the algorithm computes a mask bit as $\mathcal{S}_4 \text{ mod } 2 = 34 \text{ mod } 2 = 0$ and decides which fingerprint bit to use; $\mathcal{S}_5 \text{ mod } L = 97 \text{ mod } 8 = 1$, i.e. second bit of the fingerprint (indices start from 0) - 1.
Secondly, the mark bit value is calculated as $mask\_bit \text{ xor } fingerprint\_bit = 0 \text{ xor } 1 = 1$, and finally the mark bit is embedded into previously chosen place in the data, i.e we are changing 2nd LSB of 749 from 0 to 1 obtaining that way a fingerprinted value 751. 
The algorithm continues with the second tuple. The condition from the line 3 of \Cref{alg:AK-insertion} fails because $\mathcal{S}_1 \text{ mod } \gamma = 21 \text{ mod } 2 = 1$. Thus, the insertion algorithm does not mark this tuple and the process is over. 

\paragraph{Detection}
Algorithm \ref{alg:AK-detection} shows the pseudo-code of fingerprint detection. 
The detection algorithm must reverse the steps from the fingerprint insertion phase to detect all the bits that construct a valid fingerprint. 
In the line 2 of the algorithm, the template for the fingerprint is initialised with \textit{L} unknown values "?".
Reversing the steps from the insertion phase is possible because the pseudo-random sequence generator $\mathcal{S}$ will produce the same random number sequences when seeded with the same value.
Therefore, modelled by the insertion algorithm, it is iteratively seeded with a concatenation of a secret key $\mathcal{K}$ known only to the owner and the primary key of every single tuple.
In lines 9-12, based on random numbers from the sequence, the location of the marked bit is calculated.
In the same manner, the mask bit \textit{x} and fingerprint bit index \textit{i} are calculated, in lines 13 and 15 respectively.
Considering that in the insertion phase the value of a bit to be embedded, i.e. the mark bit \textit{m} is calculated by applying the XOR function on the fingerprint bit and the mask bit, the fingerprint bit \textit{f} is then, in reverse, calculated by applying the XOR function on the mark bit \textit{m} and the mask bit \textit{x} (line 14).
Note that the fingerprinted data set might have been under attack that changes or erases the values from the originally released fingerprinted dataset, for example, subset attack or bit-flipping attack.
This kind of attacks might disturb the fingerprint detection phase and the fingerprint bits might not be detected correctly.
The record of detected values of a fingerprint bit $f_l$ during the detection phase is kept in two count variables $count[l][0]$ and $count[l][1]$ depending if the detected bit is 0 or 1, respectively. 
When the counts for each fingerprint bit are obtained, the algorithm assigns 0 to fingerprint bit $f_l$ if the counts satisfy the condition
\begin{equation}
    count[l][0]/(count[l][0]+count[l][1])>\tau
\end{equation}
or 1 if counts satisfy the condition
\begin{equation}
    count[l][1]/(count[l][0]+count[l][1])>\tau
\end{equation}
The parameter $\tau \in [0.5, 1)$ defines assurance of the detection process.
Recovered fingerprint bits constitute the fingerprint template $\mathcal{F}=(f_0,...,f_{L-1})$ which is compared to fingerprints of buyers to detect the source of leakage. 
This process is done by the subroutine \textit{detect} described in \Cref{alg:detect-subroutine}.
The buyers' fingerprints are calculated on the fly.
If the exact match of buyer \textit{n}'s fingerprint with the fingerprint template is detected, the buyer \textit{n} is reported.

\subsection{Assumptions and Properties}
In this section, we list the assumptions and properties of AK Scheme. 
The first assumption is one that is present in all of the schemes presented in this thesis. 
We have to assume that the minor errors in numerical attributes in the dataset, necessarily caused by fingerprinting process, are not violating the integrity of the database and that those errors are tolerated by the database users. 
Besides, the AK Scheme is modelled such that it requires the presence of a primary key attribute. 
The primary key should stay unmodified or otherwise has to be recoverable for the sake of successful fingerprint detection.
The same is true for the tuple order in the database.
Since each tuple is assumed to have a unique primary key value based on which it is processed independently, the scheme is incrementally updatable. 
This means that fingerprint bits can be added to any additional tuples in the dataset at any given point in time in the future, without breaking the integrity of a fingerprinting scheme.

One more advantage of AK Scheme is blindness: It is not required to have the original database or any of the fingerprints involved in the fingerprint detection stored as the owner's secret key is involved in every step of the scheme, both embedding and detecting a fingerprint. 
